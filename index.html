<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>æœ¬æ£šæ•´ç†ã‹ã‚‰åˆ†ã‹ã‚‹AIæ€§æ ¼è¨ºæ–­</title>
    <style>
        :root {
            --bg: #0b0d12;
            --panel: #121628;
            --panel2: #0f1323;
            --text: #e8ecff;
            --muted: #aab2d6;
            --accent: #7aa2ff;
            --accent2: #8dffb5;
            --danger: #ff6b7a;
            --radius: 16px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", "Yu Gothic UI", "YuGothic", sans-serif;
            background: radial-gradient(1000px 600px at 20% 0%, #12183a, var(--bg));
            color: var(--text);
            min-height: 100vh;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        .wrap {
            max-width: 1200px;
            margin: 0 auto;
            padding: 18px 14px 60px;
            position: relative;
            /* ensure UI is above transient overlays */
            /* z-index: 10; */
        }

        /* Ensure host buttons are clickable above other transient elements during debugging */
        #genBtn {
            position: relative;
            z-index: 1000;
            pointer-events: auto;
        }

        .game-loading {
            pointer-events: none;
            user-select: none;
            opacity: 0.95;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .brand {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            box-shadow: 0 0 18px rgba(122, 162, 255, .55);
        }

        .h1 {
            font-weight: 800;
            letter-spacing: .02em;
        }

        .pill {
            font-size: 12px;
            padding: 6px 10px;
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 999px;
            color: var(--muted);
            background: rgba(0, 0, 0, .15);
        }

        .grid {
            display: grid;
            grid-template-columns: 1.05fr 1.05fr;
            gap: 14px;
            margin-top: 12px;
        }

        .grid.top-grid {
            margin-top: 0;
            margin-bottom: 14px;
        }

        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .03));
            border: 1px solid rgba(255, 255, 255, .10);
            border-radius: var(--radius);
            padding: 14px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .25);
        }

        .card h2 {
            margin: 0 0 10px;
            font-size: 16px;
            color: #f2f4ff;
        }

        .desc {
            color: var(--muted);
            font-size: 13px;
            line-height: 1.5;
            margin: 6px 0 12px;
        }

        .row {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }

        .row label {
            color: var(--muted);
            font-size: 13px;
        }

        select,
        input[type="text"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: rgba(0, 0, 0, .25);
            color: var(--text);
            outline: none;
        }

        .btns {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 12px;
        }

        button {
            border: 0;
            border-radius: 14px;
            padding: 10px 14px;
            font-weight: 700;
            color: #0b0d12;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            cursor: pointer;
        }

        button.secondary {
            background: rgba(255, 255, 255, .08);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .12);
        }

        button.ghost {
            background: transparent;
            color: var(--muted);
            border: 1px dashed rgba(255, 255, 255, .18);
        }

        .fade-in {
            opacity: 0;
            transform: translateY(4px);
            transition: opacity .4s ease, transform .4s ease;
        }

        .fade-in.show {
            opacity: 1;
            transform: translateY(0);
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed;
        }

        .out {
            background: rgba(0, 0, 0, .25);
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 14px;
            padding: 12px;
            margin-top: 12px;
            word-break: break-all;
            color: #eaf0ff;
            font-size: 13px;
            line-height: 1.5;
        }

        .out.prewrap {
            white-space: pre-wrap;
        }

        .hint {
            font-size: 12px;
            color: var(--muted);
            margin-top: 10px;
            line-height: 1.5;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono", monospace;
        }

        /* Play UI */
        #playView {
            display: none;
        }

        .playTop {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .status {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .badge {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .22);
            color: var(--muted);
        }

        .bar {
            width: 220px;
            height: 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .20);
            overflow: hidden;
        }

        .bar>i {
            display: block;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
        }

        #gameWrap {
            border-radius: var(--radius);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(0, 0, 0, .25);
        }

        /* Ensure the game container has a sensible minimum size */
        #game {
            min-height: 620px;
            height: auto;
            /* explicit height avoids 0px collapses */
            width: 100%;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            overflow: hidden;
        }

        /* DOM-based bookshelf game styles */
        .bookshelf-game {
            display: flex;
            gap: 16px;
            width: 100%;
            padding: 12px;
        }

        .bookshelf-game .init-col {
            width: 240px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            justify-content: center;
            gap: 8px;
            max-height: 600px;
            overflow: auto;
            touch-action: none; /* prevent scrolling during touch drags */
            -webkit-user-select: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        .bookshelf-game .init-col .book {
            margin: 0 !important;
        }

        .bookshelf-game .grid-col {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .bookshelf-game .rotate-col {
            width: 90px;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            padding-top: 10px;
        }

        .bookshelf-game .rotate-col button {
            width: 100%;
        }

        .diag-btn {
            position: static;
            z-index: 5;
            margin-top: 12px;
            padding: 14px 18px;
            font-size: 15px;
            border-radius: 16px;
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
            width: 100%;
            max-width: 360px;
            background: linear-gradient(135deg, #ffb26a, #ff6b7a);
            color: #121628;
        }

        .grid-root {
            background-image: linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-position: 0 0, 0 0;
            background-repeat: repeat;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            box-shadow: inset 0 2px 12px rgba(0, 0, 0, 0.3);
            touch-action: none; /* ensure touch drags work */
        }

        .book {
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.25), inset 0 -2px 8px rgba(0, 0, 0, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 700;
            user-select: none;
            -webkit-user-drag: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-drag: none;
            touch-action: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
        }

        .book::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 14px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.35), rgba(0, 0, 0, 0.15));
            border-right: 1px solid rgba(0, 0, 0, 0.25);
            opacity: 0.6;
        }

        .book[data-rot="1"]::before {
            left: 0;
            right: 0;
            top: 0;
            bottom: auto;
            width: auto;
            height: 14px;
            border-right: 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.25);
        }

        .book[data-rot="2"]::before {
            left: auto;
            right: 0;
            top: 0;
            bottom: 0;
            width: 14px;
            height: auto;
            border-right: 0;
            border-left: 1px solid rgba(0, 0, 0, 0.25);
        }

        .book[data-rot="3"]::before {
            left: 0;
            right: 0;
            top: auto;
            bottom: 0;
            width: auto;
            height: 14px;
            border-right: 0;
            border-top: 1px solid rgba(0, 0, 0, 0.25);
        }

        .book::after {
            content: "";
            position: absolute;
            inset: 6px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.22);
            opacity: 0.4;
            pointer-events: none;
        }

        .book.red {
            background: linear-gradient(180deg, #ff8a9b, #ff3a52);
        }

        .book.blue {
            background: linear-gradient(180deg, #97b6ff, #4b87ff);
        }

        .book.green {
            background: linear-gradient(180deg, #a6ffca, #45e58e);
        }

        .book.selected {
            outline: 3px solid rgba(255, 255, 255, 0.7);
            outline-offset: 2px;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.35), 0 12px 28px rgba(0, 0, 0, 0.45);
        }

        .placement-hint {
            border-radius: 6px;
            box-sizing: border-box;
        }

        .rotate-error {
            position: absolute;
            left: 50%;
            top: 8px;
            transform: translateX(-50%) translateY(-8px);
            background: rgba(255, 80, 80, 0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 700;
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
            opacity: 0;
            pointer-events: none;
            transition: opacity .18s ease, transform .24s ease;
            z-index: 10;
            white-space: nowrap;
        }
        .rotate-error.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Overlay */
        .overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, .85);
            padding: 18px;
            z-index: 20000;
        }

        .overlay .modal {
            width: min(860px, 100%);
            border-radius: 18px;
            background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .04));
            border: 1px solid rgba(255, 255, 255, .14);
            box-shadow: 0 20px 60px rgba(0, 0, 0, .5);
            padding: 16px;
        }

        .modal h3 {
            margin: 0 0 10px;
            font-size: 16px;
        }

        .modal .text {
            white-space: pre-line;
            line-height: 1.7;
            color: #eef2ff;
            font-size: 14px;
            background: rgba(0, 0, 0, .20);
            border: 1px solid rgba(255, 255, 255, .10);
            border-radius: 14px;
            padding: 12px;
            min-height: 180px;
        }

        .modal .sub {
            color: var(--muted);
            font-size: 12px;
            margin-top: 10px;
            line-height: 1.5;
        }

        .right {
            margin-left: auto;
        }
    </style>
</head>

<body>
    <script>
        try {
            console.log('sanity: inline script OK');
            const _el = document.createElement('div');
            _el.id = 'sanity-js-indicator';
            _el.style.position = 'fixed';
            _el.style.right = '12px';
            _el.style.bottom = '12px';
            _el.style.zIndex = 99999;
            _el.style.background = 'rgba(0,200,150,0.12)';
            _el.style.color = '#bfffdc';
            _el.style.padding = '6px 8px';
            _el.style.borderRadius = '6px';
            _el.style.fontSize = '12px';
            _el.textContent = 'JS OK';
            document.body && document.body.appendChild(_el);
        } catch (e) {
            console.error('sanity failure', e);
        }
    </script>
    <script>
        window.addEventListener("error", function (e) {
            // Show alert for script errors to help debugging user environment
            const msg = "Script Error: " + e.message + "\nLine: " + e.lineno;
            console.error(msg);

            const el = document.createElement('div');
            el.style.position = 'fixed';
            el.style.bottom = '0';
            el.style.left = '0';
            el.style.width = '100%';
            el.style.background = 'rgba(255, 0, 0, 0.9)';
            el.style.color = 'white';
            el.style.padding = '8px';
            el.style.fontSize = '12px';
            el.style.zIndex = '100000';
            el.style.pointerEvents = 'none';
            el.textContent = msg;
            document.body.appendChild(el);
        });
    </script>
    <div class="wrap">
        <div class="topbar">
            <div class="brand">
                <div class="dot"></div>
                <div>
                    <div class="h1">æœ¬æ£šæ•´ç†ã‹ã‚‰åˆ†ã‹ã‚‹AIæ€§æ ¼è¨ºæ–­</div>
                </div>
            </div>
            <div class="pill mono" id="routePill">#host</div>
        </div>

        <!-- HOST VIEW -->
        <div id="hostView">
            <div class="grid top-grid">
                <div class="card">
                    <h2>æ¦‚è¦</h2>
                    <div class="desc">
                        AIè¨ºæ–­é¢¨ã®ã‚¸ãƒ§ãƒ¼ã‚¯ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã§ã™ã€‚é€ã‚‹ç›¸æ‰‹ã«åˆã‚ã›ãŸåˆ†æçµæœã‚’é¸ã‚“ã§ã€ç›¸æ‰‹ã‚’ãƒ“ãƒƒã‚¯ãƒªã•ã›ã¾ã—ã‚‡ã†ã€‚
                    </div>
                    <div class="out">
                        <div><b>ç”¨é€”ï¼š</b>å‹äººã‚„å®¶æ—å‘ã‘ã®â€œéŠã³è¨ºæ–­â€</div>
                        <div style="margin-top:8px;"><b>å…±æœ‰æ–¹æ³•ï¼š</b>ç”Ÿæˆã—ãŸURLã‚’é€ã‚‹ã ã‘</div>
                        <div style="margin-top:8px;"><b>æ‰€è¦æ™‚é–“ï¼š</b>1~2åˆ†ç¨‹åº¦</div>
                    </div>
                </div>
                <div class="card">
                    <h2>è¨ºæ–­ã®æµã‚Œï¼ˆç›¸æ‰‹å´ï¼‰</h2>
                    <div class="desc">
                        ç›¸æ‰‹å´ã¯ä¸‹è¨˜ã®ãƒ•ãƒ­ãƒ¼ã«å¾“ã£ã¦è¨ºæ–­ã‚’å—ã‘ã¾ã™ã€‚
                    </div>

                    <div class="out">
                        <div><b>ãƒŸãƒ‹ãƒ‘ã‚ºãƒ«ï¼š</b>æœ¬ã‚’æ£šã«ä¸¦ã¹ã‚‹ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ï¼‰</div>
                        <div style="margin-top:8px;"><b>è§£ææ¼”å‡ºï¼š</b>åˆ†æé¢¨ã®æ¼”å‡ºã‚’è¡Œã†</div>
                        <div style="margin-top:8px;"><b>çµæœï¼š</b>é¸ã‚“ã æ–‡ç« ã‚’è¡¨ç¤º</div>
                        <div style="margin-top:8px;"><b>ãƒã‚¿ãƒãƒ©ã‚·ï¼š</b>å®Ÿã¯ã‚ãªãŸãŒé¸ã‚“ã æ–‡ç« ã§ã—ãŸã€‚</div>
                    </div>
                </div>
            </div>
            <div class="grid">
                <div class="card">
                    <h2>ãƒ›ã‚¹ãƒˆï¼ˆã—ã‹ã‘ã‚‹å´ï¼‰</h2>
                    <div class="desc">
                        ã—ã‹ã‘ã‚‹ç›¸æ‰‹ã«åˆã‚ã›ã¦é¸æŠè‚¢ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚ãã®å¾Œã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚’ã‚’æŠ¼ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã¨URLã‚’å…±æœ‰ã™ã‚‹ã¨ã€ç›¸æ‰‹ãŒã‚¸ãƒ§ãƒ¼ã‚¯è¨ºæ–­ã‚’å—ã‘ã‚‰ã‚Œã¾ã™ã€‚
                    </div>

                    <div class="row">
                        <label>è¨ºæ–­çµæœã®ã‚¿ã‚¤ãƒ—</label>
                        <select id="tone"></select>
                    </div>
                    <div class="row">
                        <label>å¼·ã¿</label>
                        <select id="strength"></select>
                    </div>
                    <div class="row">
                        <label>å¼±ã¿</label>
                        <select id="state"></select>
                    </div>
                    <div class="row">
                        <label>å‚¾å‘</label>
                        <select id="relation"></select>
                    </div>
                    <div class="row">
                        <label>å¹´é½¢</label>
                        <select id="wordA"></select>
                    </div>
                    <div class="row">
                        <label>å¥½ããªé£Ÿã¹ç‰©</label>
                        <select id="wordB"></select>
                    </div>

                    <div class="btns">
                        <button id="genBtn">ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ</button>
                        <button class="secondary" id="copyBtn" disabled>URLã‚³ãƒ”ãƒ¼</button>
                        <button class="ghost right" id="goPlayBtn" disabled>ã“ã®ç«¯æœ«ã§è©¦ã™</button>
                    </div>

                    <div class="out mono" id="shareOut">ã“ã“ã«URLãŒå‡ºã¾ã™</div>

                    <!-- <div class="btns">
                        <button class="ghost" id="diagBtnHost">è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ</button>
                        <button class="ghost" id="reinitBtnHost">å†åˆæœŸåŒ–</button>
                    </div> -->
                </div>

                <div class="card" id="previewCard">
                    <h2>é¸æŠä¸­ã®æ–‡æ›¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
                    <div class="desc">
                        ã„ã¾é¸ã‚“ã§ã„ã‚‹å†…å®¹ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹æ–‡æ›¸ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¡¨ç¤ºã—ã¾ã™ã€‚
                    </div>
                    <div class="out prewrap" id="previewOut">ã“ã“ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
                    <div class="hint">â€»ã‚³ãƒ¼ãƒ‰ç”Ÿæˆæ™‚ã¯ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ãŒå…¥ã‚‹ãŸã‚ã€æ–‡é¢ãŒå°‘ã—å¤‰ã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</div>
                </div>
            </div>
        </div>

        <!-- PLAY VIEW -->
        <div id="playView">
            <div class="card" style="margin-bottom:14px;">
                <div class="playTop">
                    <div>
                        <h2 style="margin:0 0 6px;">æœ¬æ£šæ•´ç†ã‹ã‚‰åˆ†ã‹ã‚‹AIæ€§æ ¼è¨ºæ–­</h2>
                        <div class="desc" style="margin:0;">
                            ãƒ­ãƒ¼ãƒ«ã‚·ãƒ£ãƒƒãƒãƒ»ãƒ†ã‚¹ãƒˆã‚„ãƒã‚¦ãƒ ãƒ†ã‚¹ãƒˆã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å—ã‘ãŸã€AIè¨ºæ–­ã§ã™ã€‚<br>ã‚ãªãŸã®æœ¬ã®æ•´ç†ã®ä»•æ–¹ã‚’å…ƒã«AIãŒåˆ†æã—ã¦æ€§æ ¼è¨ºæ–­ã‚’è¡Œã„ã¾ã™ã€‚
                            <h2 style="margin:12px 0 6px;">éŠã³æ–¹</h2>
                            å·¦ã«ã‚ã‚‹æœ¬ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§å³ã®ã‚°ãƒªãƒƒãƒ‰(æœ¬æ£š)ã«è‡ªç”±ã«ä¸¦ã¹ã¦ãã ã•ã„ã€‚<br />
                            è‡ªåˆ†ãŒå¿ƒåœ°ã‚ˆã„ã¨æ€ã†ã‚ˆã†ã«æœ¬ã‚’é…ç½®ã—ã¾ã—ã‚‡ã†ã€‚
                            <br />
                            ä¸¦ã¹çµ‚ã‚ã£ãŸã‚‰ã€å³ã®è¨ºæ–­çµæœã‚’è¦‹ã‚‹ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ä¸‹ã•ã„ã€‚
                            <h2 style="margin:12px 0 6px;">æ“ä½œæ–¹æ³•</h2>
                            æœ¬ã®ç§»å‹•ï¼šãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—<br />
                            æœ¬ã®å›è»¢ï¼šæœ¬ã‚’é¸æŠã—ã¦ã€å›è»¢ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™<br />
                        </div>
                    </div>

                </div>
            </div>

            <div id="gameWrap" class="card" style="padding:0;">
                <div id="game"></div>
            </div>

        </div>
    </div>

    <!-- RESULT OVERLAY -->
    <div class="overlay" id="overlay">
        <div class="modal">
            <h3 id="ovTitle">è§£æä¸­â€¦</h3>
            <div class="text" id="ovText">ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚</div>
            <div class="btns" style="margin-top:12px;">
                <button class="secondary fade-in" id="revealBtn" style="display:none;">ãƒã‚¿ãƒãƒ¬ã¸é€²ã‚€</button>
                <button class="secondary fade-in" id="toHostBtn" style="display:none;">ãƒ›ã‚¹ãƒˆç”»é¢ã¸</button>
                <button class="secondary right" id="closeBtn" style="display:none;">é–‰ã˜ã‚‹</button>
            </div>
            <div class="sub" id="ovSub"></div>
        </div>
    </div>

    <!-- Phaser removed: using DOM-based bookshelf implementation -->

    <script>
        'use strict';
        /********************
         * Data (Host choices)
         ********************/
        const TONES = [
            "å®‰å®šå¿—å‘ã‚¿ã‚¤ãƒ—",
            "æˆé•·åŠ é€Ÿã‚¿ã‚¤ãƒ—",
            "åˆ†æé‡è¦–ã‚¿ã‚¤ãƒ—",
            "å”èª¿æ€§é‡è¦–ã‚¿ã‚¤ãƒ—",
            "é–¢ä¿‚é‡è¦–ã‚¿ã‚¤ãƒ—",
            "æŒ‘æˆ¦æ¨é€²ã‚¿ã‚¤ãƒ—"
        ];
        const STRENGTHS = ["è¨ˆç”»æ€§", "å®Ÿè¡ŒåŠ›", "è¦³å¯ŸåŠ›", "èª¿æ•´åŠ›", "ç¶™ç¶šåŠ›", "åˆ¤æ–­åŠ›"];
        const STATES = ["æ…é‡ã™ãã‚‹", "è¦–é‡ãŒç‹­ã„", "å®Œç’§ä¸»ç¾©", "å„ªæŸ”ä¸æ–­", "é ‘å›º", "é£½ãã‚„ã™ã„"];
        const RELATIONS = ["è«–ç†å„ªå…ˆ", "ç›´æ„Ÿå„ªå…ˆ", "å”èª¿å„ªå…ˆ", "ç‹¬ç«‹å„ªå…ˆ", "æ…é‡å„ªå…ˆ", "æŒ‘æˆ¦å„ªå…ˆ"];

        const AGE16 = [
            "10ä»£", "20æ­³", "21ã€œ25æ­³", "26ã€œ30æ­³",
            "31ã€œ35æ­³", "36ã€œ40æ­³", "41ã€œ45æ­³", "46ã€œ50æ­³",
            "51ã€œ55æ­³", "56ã€œ60æ­³", "61ã€œ65æ­³", "66ã€œ70æ­³",
            "71ã€œ75æ­³", "76ã€œ80æ­³", "81ã€œ85æ­³", "86æ­³ä»¥ä¸Š"
        ];

        const FOOD16 = [
            "ã‚«ãƒ¬ãƒ¼", "å¯¿å¸", "ãƒ©ãƒ¼ãƒ¡ãƒ³", "ç„¼è‚‰",
            "ãƒ‘ã‚¹ã‚¿", "ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼", "ãƒ”ã‚¶", "å”æšã’",
            "é¤ƒå­", "é‹æ–™ç†", "ãŠå¥½ã¿ç„¼ã", "ã‚¹ã‚¤ãƒ¼ãƒ„",
            "ã‚µãƒ©ãƒ€", "ãƒ‘ãƒ³", "ä¸¼ã‚‚ã®", "å’Œè“å­"
        ];

        // 9 segments, each 6 variants â€” expanded into diagnostic-style paragraphs (SNS Friendly Ver)
        const SEG = {
            intro: [
                "ğŸ‘‘ã€åŸºæœ¬æ€§æ ¼ã€‘\nå…¨ä½“ã‚’ã‚µã‚¯ãƒƒã¨æŠŠæ¡ã—ã¦ã‹ã‚‰å‹•ãã€ŒåŠ¹ç‡é‡è¦–ã€ã‚¿ã‚¤ãƒ—ï¼ç„¡é§„ãªã“ã¨ã¯ã—ãŸããªã„ã€ã‚¹ãƒãƒ¼ãƒˆãªæˆ¦ç•¥å®¶ã§ã™âœ¨",
                "âš–ï¸ã€åŸºæœ¬æ€§æ ¼ã€‘\nã¾ãšã¯æ¯”è¼ƒãƒ»æ¤œè¨ï¼ã˜ã£ãã‚Šæƒ…å ±ã‚’é›†ã‚ã¦ã‹ã‚‰æ±ºæ–­ã™ã‚‹ã€Œæ…é‡æ´¾ã€ã•ã‚“ã€‚å¤±æ•—ã®å°‘ãªã„å …å®Ÿãªæ­©ã¿ãŒã§ãã‚‹äººã§ã™ğŸ¢",
                "ğŸ§±ã€åŸºæœ¬æ€§æ ¼ã€‘\nã‚³ãƒ„ã‚³ãƒ„ç©ã¿ä¸Šã’ã‚‹ã€Œå®Ÿç¸¾é‡è¦–ã€ã‚¿ã‚¤ãƒ—ã€‚ä¸€ç™ºé€†è»¢ã‚ˆã‚Šã€ç¢ºå®Ÿãªæˆæœã‚’æ„›ã™ã‚‹å®‰å®šæ„Ÿã®æŒã¡ä¸»ï¼ä¿¡é ¼åº¦ãƒãƒ„ã‚°ãƒ³ã§ã™ğŸ”¥",
                "ğŸ¨ã€åŸºæœ¬æ€§æ ¼ã€‘\nä¸å¯§ã•ãŒå…‰ã‚‹ã€Œè·äººè‚Œã€ã‚¿ã‚¤ãƒ—ã€‚ç´°ã‹ã„ã¨ã“ã‚ã«ã‚‚æ°—ã‚’é…ã‚Šã€å“è³ªã®é«˜ã„ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆãŒå‡ºã›ã‚‹æ‰èƒ½ãŒã‚ã‚Šã¾ã™ğŸ’",
                "ğŸ¤ã€åŸºæœ¬æ€§æ ¼ã€‘\nã¿ã‚“ãªã®ã¾ã¨ã‚å½¹ï¼ã€Œèª¿å’Œã€ã‚’å¤§åˆ‡ã«ã™ã‚‹å¹³å’Œä¸»ç¾©è€…ã€‚ç©ºæ°—ã‚’èª­ã‚€ã®ãŒã†ã¾ãã€ãƒãƒ¼ãƒ ã«ä¸€äººã¯æ¬²ã—ã„å­˜åœ¨ã§ã™ğŸ•Šï¸",
                "ğŸš€ã€åŸºæœ¬æ€§æ ¼ã€‘\næ€ã„ç«‹ã£ãŸã‚‰å³è¡Œå‹•â€¦ã®å‰ã«æ®µå–ã‚Šï¼ã€Œè¨ˆç”»å®Ÿè¡Œã€ã‚¿ã‚¤ãƒ—ã€‚æº–å‚™ä¸‡ç«¯ã§æŒ‘ã‚€ã‹ã‚‰ã€å‘¨ã‚Šã‚‚å®‰å¿ƒã—ã¦ã¤ã„ã¦ã“ã‚Œã¾ã™ğŸš™"
            ],
            first: [
                "ğŸ’ªã€æ¨ã—ãƒã‚¤ãƒ³ãƒˆã€‘\nãªã‚“ã¨ã„ã£ã¦ã‚‚ã€Œ{S}ã€ãŒã‚ãªãŸã®æ­¦å™¨ï¼è¿·ã‚ãšã‚¹ã‚¿ãƒ¼ãƒˆã‚’åˆ‡ã‚Œã‚‹è¡Œå‹•åŠ›ã¯ã€å‘¨ã‚Šã‹ã‚‰ã‚‚ä¸€ç›®ç½®ã‹ã‚Œã¦ã„ã¾ã™ğŸ‘€",
                "ğŸ§ ã€æ¨ã—ãƒã‚¤ãƒ³ãƒˆã€‘\nã€Œ{S}ã€ã®ã‚¹ã‚­ãƒ«ãŒé«˜ã‚ï¼æƒ…å ±ã‚’æ•´ç†ã—ã¦ã‚¯ãƒªã‚¢ã«è€ƒãˆã‚‹åŠ›ãŒã‚ã‚Šã€ç›¸è«‡å½¹ã«ã´ã£ãŸã‚Šã§ã™ğŸ§â€â™‚ï¸",
                "ğŸŒ³ã€æ¨ã—ãƒã‚¤ãƒ³ãƒˆã€‘\nã‚ãªãŸã®å¼·ã¿ã¯ã€Œ{S}ã€ã€‚åŸºç¤ã‚’å¤§äº‹ã«ã™ã‚‹å§¿å‹¢ãŒã€é•·æœŸçš„ã«å¤§ããªçµæœã‚’ç”Ÿã¿ã¾ã™ã€‚å¤§å™¨æ™©æˆã‹ã‚‚ï¼ï¼ŸğŸ¥š",
                "ğŸŒŠã€æ¨ã—ãƒã‚¤ãƒ³ãƒˆã€‘\nã€Œ{S}ã€ãŒã§ãã‚‹æŸ”è»Ÿæ€§ãŒé­…åŠ›ï¼ã©ã‚“ãªçŠ¶æ³ã§ã‚‚å¯¾å¿œã§ãã‚‹ã‚µãƒã‚¤ãƒãƒ«èƒ½åŠ›ã®é«˜ã•ãŒå…‰ã‚Šã¾ã™ğŸ”¦",
                "ğŸ¤–ã€æ¨ã—ãƒã‚¤ãƒ³ãƒˆã€‘\nã€Œ{S}ã€ã®ç²¾åº¦ãŒã™ã”ã„ï¼ãƒ ãƒ©ã®ãªã„ä»•äº‹ã¶ã‚Šã¯ã€ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ã¨ã—ã¦é‡å®ã•ã‚Œã‚‹ã¯ãšâš™ï¸",
                "âš¡ã€æ¨ã—ãƒã‚¤ãƒ³ãƒˆã€‘\nã€Œ{S}ã€ã®ã‚¹ãƒ”ãƒ¼ãƒ‰æ„ŸãŒæœ€é«˜ï¼åˆ‡ã‚Šæ›¿ãˆãŒæ—©ãã€ãƒ†ã‚­ãƒ‘ã‚­é€²ã‚ã‚‹å§¿ãŒã‚«ãƒƒã‚³ã‚¤ã‚¤ã§ã™ğŸï¸"
            ],
            core: [
                "âš ï¸ã€ã¡ã‚‡ã£ã´ã‚Šæ³¨æ„ã€‘\nå¼±ç‚¹ãŒã‚ã‚‹ã¨ã™ã‚Œã°ã€Œ{W}ã€ãªã¨ã“ã‚ã€‚ã“ã“ãã¨ã„ã†æ™‚ã¯ã€ãˆã„ã‚„ï¼ã§æ±ºã‚ã‚‹å‹‡æ°—ãŒã‚«ã‚®ã‹ã‚‚ğŸ—ï¸",
                "ğŸ˜°ã€ã¡ã‚‡ã£ã´ã‚Šæ³¨æ„ã€‘\nç„¦ã‚‹ã¨ã€Œ{W}ã€ã«ãªã‚ŠãŒã¡ã€‚ãƒ†ãƒ³ãƒ‘ã£ãŸæ™‚ã¯æ·±å‘¼å¸ã—ã¦â˜• ãŠèŒ¶ã§ã‚‚é£²ã‚“ã§è½ã¡ç€ãã¾ã—ã‚‡ã†ã€‚",
                "ğŸš§ã€ã¡ã‚‡ã£ã´ã‚Šæ³¨æ„ã€‘\nã“ã ã‚ã‚Šã™ãã¦ã€Œ{W}ã€ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã€‚70ç‚¹ã§ã¨ã‚Šã‚ãˆãšé€²ã‚ã¡ã‚ƒãŠã†ï¼ãã‚‰ã„ã®è»½ã•ã‚‚å¤§äº‹ã§ã™ğŸˆ",
                "ğŸ”‹ã€ã¡ã‚‡ã£ã´ã‚Šæ³¨æ„ã€‘\nç–²ã‚ŒãŒæºœã¾ã‚‹ã¨ã€Œ{W}ã€ãŒå‡ºã¡ã‚ƒã†ã‹ã‚‚ã€‚è‡ªåˆ†ã®æ©Ÿå«Œã‚’ã¨ã‚‹ã®ã‚‚å¤§äº‹ãªã‚¹ã‚­ãƒ«ã®ã²ã¨ã¤ã§ã™ï¼ğŸ›Œ",
                "ğŸ¤¯ã€ã¡ã‚‡ã£ã´ã‚Šæ³¨æ„ã€‘\nã‚ã‚Œã‚‚ã“ã‚Œã‚‚ã¨æŠ±ãˆè¾¼ã‚“ã§ã€Œ{W}ã€ã«ãªã£ã¦ãªã„ï¼Ÿå„ªå…ˆé †ä½ã‚’ã¤ã‘ã¦ã€æ‰‹æ”¾ã™å‹‡æ°—ã‚’æŒã¡ã¾ã—ã‚‡ã†ğŸ‘‹",
                "ğŸ¢ã€ã¡ã‚‡ã£ã´ã‚Šæ³¨æ„ã€‘\næ„Ÿæƒ…ã®æ³¢ã§ã€Œ{W}ã€ã«ãªã‚Šã‚„ã™ã„æ™‚ã‚‚ã€‚ãƒã‚¤ãƒ«ãƒ¼ãƒ«ã‚’ä½œã£ã¦ã€æ·¡ã€…ã¨ã“ãªã™ãƒ¢ãƒ¼ãƒ‰ã‚’æŒã¤ã¨æœ€å¼·ã§ã™ğŸ¤–"
            ],
            hidden: [
                "ğŸ”ã€æ€è€ƒã®ã‚¯ã‚»ã€‘\nå®Ÿã¯ã€Œ{T}ã€ãªå‚¾å‘ã‚¢ãƒªã€‚ãƒ–ãƒ¬ãªã„è»¸ã‚’æŒã£ã¦ã„ã¦ã€è‡ªåˆ†ã®ä¿¡å¿µã«åŸºã¥ã„ãŸè¡Œå‹•ãŒã§ãã‚‹äººã§ã™ã€‚",
                "ğŸš¦ã€æ€è€ƒã®ã‚¯ã‚»ã€‘\nã€Œ{T}ã€ã‚¹ã‚¿ã‚¤ãƒ«ã§å„ªå…ˆé †ä½ã‚’æ±ºã‚ã‚‹ã‚¿ã‚¤ãƒ—ã€‚ä½•ãŒä¸€ç•ªå¤§äº‹ã‹ã€ç›´æ„Ÿçš„ã«ã‚ã‹ã£ã¦ã„ã‚‹ã®ãŒå¼·ã¿ï¼",
                "ğŸ’­ã€æ€è€ƒã®ã‚¯ã‚»ã€‘\né ­ã®ä¸­ã¯æ„å¤–ã¨ã€Œ{T}ã€ã€‚ä¸€åº¦ã“ã†ã¨æ€ã†ã¨çªãé€²ã‚€ãƒ‘ãƒ¯ãƒ¼ãŒã‚ã‚Šã¾ã™ãŒã€ãŸã¾ã«ã¯å¯„ã‚Šé“ã‚‚ã„ã„ã‹ã‚‚ï¼Ÿ",
                "ğŸ“ã€æ€è€ƒã®ã‚¯ã‚»ã€‘\nåˆ¤æ–­åŸºæº–ã¯ã€Œ{T}ã€ã€‚ä¸€è²«æ€§ãŒã‚ã‚‹ã®ã§ã€å‘¨ã‚Šã‹ã‚‰ã¯ã€Œãƒ–ãƒ¬ãªã„äººã€ã¨ã—ã¦ä¿¡é ¼ã•ã‚Œã¦ã„ã¾ã™âœ¨",
                "ğŸ“ã€æ€è€ƒã®ã‚¯ã‚»ã€‘\né€²ã‚æ–¹ã®å¥½ã¿ã¯ã€Œ{T}ã€ã€‚è‡ªåˆ†ãªã‚Šã®å‹ã‚’æŒã£ã¦ã„ã¦ã€ãã‚Œã«ãƒãƒã‚‹ã¨çˆ†é€Ÿã§æˆæœãŒå‡ºã›ã‚‹ã‚¿ã‚¤ãƒ—ï¼",
                "ğŸ¦ã€æ€è€ƒã®ã‚¯ã‚»ã€‘\nçŠ¶æ³ã«ã‚ˆã£ã¦ã¯ã€Œ{T}ã€ãªå¯¾å¿œã‚‚ã€‚ã‚«ãƒ¡ãƒ¬ã‚ªãƒ³ã®ã‚ˆã†ã«ç’°å¢ƒã«åˆã‚ã›ã‚‰ã‚Œã‚‹å™¨ç”¨ã•ãŒã‚ã‚Šã¾ã™ğŸŒˆ"
            ],
            fatigue: [
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nå¥½å¥‡å¿ƒã§å‹•ã‘ã‚‹ãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã•ãŒé­…åŠ›ã€‚ã‚„ã£ã¦ã¿ã¦ã‹ã‚‰è€ƒãˆã‚‹å‹¢ã„ãŒå¼·ã¿ã§ã™âœ¨",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\næ–°ã—ã„ç’°å¢ƒã§ã‚‚å¸åãŒæ—©ãã€æŒ‘æˆ¦ãŒãã®ã¾ã¾æˆé•·ã«ç›´çµã™ã‚‹ã‚¿ã‚¤ãƒ—ã€‚ä¼¸ã³ã—ã‚ãŒå¤§ãã„ã§ã™ğŸŒ±",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nè©¦è¡ŒéŒ¯èª¤ã—ãªãŒã‚‰è‡ªåˆ†ã®å‹ã‚’ä½œã£ã¦ã„ã‘ã‚‹æ™‚æœŸã€‚å¤±æ•—ã‚‚çµŒé¨“å€¤ã«å¤‰ãˆã¦å‰ã«é€²ã‚ã¾ã™ğŸ§ª",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nè¡Œå‹•ã¨è¨ˆç”»ã®ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚Šã‚„ã™ãã€ã‚„ã‚‹ã¹ãã“ã¨ã‚’ç¾å®Ÿçš„ã«ç©ã¿ä¸Šã’ã‚‰ã‚Œã‚‹å®‰å®šæ„ŸãŒã‚ã‚Šã¾ã™ğŸ“Œ",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nå‘¨å›²ã‚’è¦‹ãªãŒã‚‰è‡ªåˆ†ã®ãƒšãƒ¼ã‚¹ã‚’ä¿ã¦ã‚‹ã‚¿ã‚¤ãƒ—ã€‚ç„¡ç†ã›ãšçµæœã‚’å‡ºã™ã‚³ãƒ„ã‚’æ´ã¿å§‹ã‚ã¦ã„ã¾ã™âš–ï¸",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nè¦–é‡ãŒåºƒãŒã£ã¦ã€é•·æœŸç›®ç·šã§é¸ã¹ã‚‹è½ã¡ç€ããŒå‡ºã¦ãã¾ã™ã€‚é ‘å¼µã‚Šæ–¹ãŒä¸Šæ‰‹ã«ãªã£ã¦ããŸè¨¼æ‹ ã§ã™ğŸŒ¿",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nçµŒé¨“ã‚’æ´»ã‹ã—ã¦åŠ¹ç‡è‰¯ãå›ã›ã‚‹ã‚¿ã‚¤ãƒ—ã€‚å–æ¨é¸æŠãŒã†ã¾ãã€å„ªå…ˆé †ä½ã‚’æ±ºã‚ã‚‹ã®ãŒå¾—æ„ã§ã™ğŸ—‚ï¸",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nè½ã¡ç€ãã¨è¡Œå‹•åŠ›ã®ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„æ™‚æœŸã€‚ç„¦ã‚‰ãšç€å®Ÿã«é€²ã‚ã‚‰ã‚Œã‚‹ä¿¡é ¼æ„ŸãŒã‚ã‚Šã¾ã™ğŸ§±",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nåŸ¹ã£ãŸçµŒé¨“ã‚’åˆ¤æ–­ã«æ´»ã‹ã›ã‚‹ã‚¿ã‚¤ãƒ—ã€‚ãƒ–ãƒ¬ã«ãã„è»¸ãŒã‚ã‚Šã€æ±ºæ–­ãŒå®‰å®šã—ã¾ã™ğŸ§­",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nã€ç„¡ç†ã—ãªã„æˆ¦ç•¥ã€ãŒä¸Šæ‰‹ã€‚ä½“åŠ›ãƒ»æ™‚é–“ã®é…åˆ†ã‚’è€ƒãˆãªãŒã‚‰ã€å …å®Ÿã«çµæœã‚’å‡ºã›ã¾ã™â³",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nä½™è£•ã®ã‚ã‚‹è¦–ç‚¹ã§å‘¨ã‚Šã‚’æ”¯ãˆã‚‰ã‚Œã‚‹ã‚¿ã‚¤ãƒ—ã€‚èƒŒä¸­ã§è¦‹ã›ã‚‹å®‰å¿ƒæ„ŸãŒé­…åŠ›ã§ã™ğŸ«¶",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nã“ã‚Œã¾ã§ã®ç©ã¿é‡ã­ãŒå¼·ã¿ã«ãªã£ã¦ã„ã‚‹æ™‚æœŸã€‚å®‰å®šã—ãŸåˆ¤æ–­ã¨ç¶™ç¶šåŠ›ãŒå…‰ã‚Šã¾ã™ğŸ†",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nã€å¤§äº‹ãªã‚‚ã®ã‚’å¤§äº‹ã«ã™ã‚‹ã€æ„Ÿè¦šãŒè‚²ã£ã¦ã„ã¦ã€ã¶ã‚Œãªã„ä¾¡å€¤è¦³ã§é¸ã¹ã‚‹ã‚¿ã‚¤ãƒ—ã§ã™ğŸ",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\nç©ã‚„ã‹ã•ã¨èŠ¯ã®å¼·ã•ãŒåŒå±…ã€‚å‘¨ã‚Šã®å¤‰åŒ–ã«ã‚‚æ…Œã¦ãšã€è‡ªåˆ†ã®ãƒšãƒ¼ã‚¹ã§æ•´ãˆã‚‰ã‚Œã¾ã™ğŸµ",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\näººç”Ÿã®çŸ¥æµãŒè¨€è‘‰ã‚„åˆ¤æ–­ã«ã«ã˜ã‚€ã‚¿ã‚¤ãƒ—ã€‚è½ã¡ç€ãã ã‘ã§ãªãã€ãƒ¦ãƒ¼ãƒ¢ã‚¢ã‚‚æ­¦å™¨ã§ã™ğŸ“š",
                "ğŸ•¯ï¸ã€ç²¾ç¥å¹´é½¢è¨ºæ–­ã€‘\nã‚ãªãŸã®ç²¾ç¥å¹´é½¢ã¯ã€Œ{A}ã€ã£ã½ã„ï¼\né”è¦³ã—ãŸè¦–ç‚¹ã§ã€ç‰©äº‹ã‚’å¤§å±€ã‹ã‚‰è¦‹ã‚‰ã‚Œã‚‹äººã€‚å‘¨ã‚Šã‚’å®‰å¿ƒã•ã›ã‚‹åŒ…å®¹åŠ›ãŒã‚ã‚Šã¾ã™ğŸŒ™"
            ],
            relation: [
                "ğŸ½ï¸ã€å¥½ããªé£Ÿã¹ç‰©ã€‘\nã‚ãªãŸã®å¥½ããªé£Ÿã¹ç‰©ã¯ã‚ºãƒãƒªã€Œ{B}ã€ï¼\nå®šç•ªã®ç¾å‘³ã—ã•ãŒã€ç–²ã‚ŒãŸå¿ƒã‚’ãƒ›ãƒƒã¨ç™’ã‚„ã—ã¦ãã‚Œã¾ã™ã‚ˆã­ğŸ¥°",
                "ğŸ±ã€å¥½ããªé£Ÿã¹ç‰©ã€‘\nã‚ãªãŸã®å¥½ããªé£Ÿã¹ç‰©ã¯ã‚ºãƒãƒªã€Œ{B}ã€ï¼\nç´ æã®è‰¯ã•ã‚’ç”Ÿã‹ã—ãŸã‚ã®å‘³ã€ä½•åº¦é£Ÿã¹ã¦ã‚‚é£½ãã¾ã›ã‚“ã‚ˆã­âœ¨",
                "ğŸœã€å¥½ããªé£Ÿã¹ç‰©ã€‘\nã‚ãªãŸã®å¥½ããªé£Ÿã¹ç‰©ã¯ã‚ºãƒãƒªã€Œ{B}ã€ï¼\nã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒãƒ£ãƒ¼ã‚¸ã«æœ€é©ï¼ä¸€å£é£Ÿã¹ã‚‹ã ã‘ã§å…ƒæ°—ãŒå‡ºã¾ã™ã‚ˆã­ğŸ’ª",
                "ğŸã€å¥½ããªé£Ÿã¹ç‰©ã€‘\nã‚ãªãŸã®å¥½ããªé£Ÿã¹ç‰©ã¯ã‚ºãƒãƒªã€Œ{B}ã€ï¼\nã“ã ã‚ã‚Šã®è©°ã¾ã£ãŸæœ€é«˜ã®æ–™ç†ã€‚ãã®å¥¥æ·±ã•ãŒãŸã¾ã‚Šã¾ã›ã‚“ã‚ˆã­ğŸ¨",
                "ğŸ²ã€å¥½ããªé£Ÿã¹ç‰©ã€‘\nã‚ãªãŸã®å¥½ããªé£Ÿã¹ç‰©ã¯ã‚ºãƒãƒªã€Œ{B}ã€ï¼\nã¿ã‚“ãªã§ã‚·ã‚§ã‚¢ã—ã¦ã‚‚è‰¯ã—ã€ä¸€äººã§æ¥½ã—ã‚“ã§ã‚‚è‰¯ã—ãªä¸‡èƒ½ã•ãŒæœ€é«˜ã§ã™ã‚ˆã­ğŸ²",
                "ğŸ•ã€å¥½ããªé£Ÿã¹ç‰©ã€‘\nã‚ãªãŸã®å¥½ããªé£Ÿã¹ç‰©ã¯ã‚ºãƒãƒªã€Œ{B}ã€ï¼\nã‚ã®é¦™ã‚Šã¨å‘³ã‚ã„â€¦æ€ã„å‡ºã™ã ã‘ã§ãŠè…¹ãŒç©ºã„ã¦ãã¡ã‚ƒã„ã¾ã™ã‚ˆã­ğŸ˜‹"
            ],
            phase: [
                "ğŸŒŸã€ç·è©•ã€‘\nãƒãƒ©ãƒ³ã‚¹æ„Ÿè¦šãŒãƒãƒ„ã‚°ãƒ³ï¼æˆ¦ç•¥çš„ã«ç‰©äº‹ã‚’é€²ã‚ã‚‰ã‚Œã‚‹ã®ã§ã€é•·æœŸçš„ã«æˆåŠŸã—ã‚„ã™ã„ã‚¿ã‚¤ãƒ—ã§ã™ğŸ“ˆ",
                "ğŸŒ±ã€ç·è©•ã€‘\nã®ã³ã—ã‚ç„¡é™å¤§ï¼ç’°å¢ƒã«åˆã‚ã›ã¦è‡ªåˆ†ã‚’å¤‰ãˆã‚‰ã‚Œã‚‹æŸ”è»Ÿæ€§ãŒã€ã“ã‚Œã‹ã‚‰ã®é£›èºã‚’ç´„æŸã—ã¦ã„ã¾ã™ğŸš€",
                "ğŸ¹ã€ç·è©•ã€‘\nç‹™ã£ãŸç²ç‰©ã¯é€ƒãŒã•ãªã„å®Ÿè¡ŒåŠ›ï¼é™ã‹ã«ã€ã§ã‚‚ç¢ºå®Ÿã«ç›®æ¨™ã‚’é”æˆã™ã‚‹ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã®ã‚ˆã†ãªäººã§ã™ğŸ”«",
                "âš–ï¸ã€ç·è©•ã€‘\næ”»ã‚ã¨å®ˆã‚Šã®ãƒãƒ©ãƒ³ã‚¹ãŒçµ¶å¦™ã€‚ãƒãƒ¼ãƒ ã®è¦ã¨ã—ã¦ã€ãªãã¦ã¯ãªã‚‰ãªã„å­˜åœ¨ã«ãªã‚‹ã§ã—ã‚‡ã†ğŸ…",
                "ğŸ’ã€ç·è©•ã€‘\nç£¨ã‘ã°å…‰ã‚‹åŸçŸ³ï¼æˆ¦ç•¥ã‚’æŒã£ã¦å–ã‚Šçµ„ã‚ã°ã€æƒ³åƒä»¥ä¸Šã®æˆæœãŒå‡ºã‚‹ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«ã‚’ç§˜ã‚ã¦ã„ã¾ã™âœ¨",
                "ğŸ—ï¸ã€ç·è©•ã€‘\nåŸºç›¤ã‚’ä½œã‚‹ã®ãŒã†ã¾ã„å»ºç¯‰å®¶ã‚¿ã‚¤ãƒ—ã€‚ã‚ãªãŸã®ä½œã£ãŸä»•çµ„ã¿ãŒã€ã¿ã‚“ãªã‚’åŠ©ã‘ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ğŸ "
            ],
            advice: [
                "ğŸ’¡ã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€‘\nã‚ã‚Œã“ã‚Œè©°ã‚è¾¼ã¿ã™ãã‚‹ã¨ãƒ‘ãƒ³ã‚¯ã—ã¡ã‚ƒã†ã‹ã‚‚ã€‚ä½™ç™½ï¼ˆãƒãƒƒãƒ•ã‚¡ï¼‰ã‚’ä½œã‚‹å‹‡æ°—ã‚’æŒã£ã¦ï¼ğŸ›€",
                "ğŸ‘‚ã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€‘\nã€Œè¤’ã‚è¨€è‘‰ã€ã¯ç´ ç›´ã«å—ã‘å–ã‚ã†ï¼è‡ªå·±è‚¯å®šæ„Ÿã‚’ä¸Šã’ã‚‹ã®ãŒã€é‹æ°—ã‚¢ãƒƒãƒ—ã®è¿‘é“ã§ã™ğŸ’–",
                "ğŸ›‘ã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€‘\nã€Œã‚„ã‚‰ãªã„ã“ã¨ã€ã‚’æ±ºã‚ã‚‹ã®ãŒå¤§äº‹ï¼8å‰²ã®åŠ›ã§å›ã™ã“ã¨ã‚’æ„è­˜ã™ã‚‹ã¨ã€é€†ã«è³ªãŒä¸ŠãŒã‚Šã¾ã™â¤´ï¸",
                "ğŸï¸ã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€‘\nã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã¾ãšã€ŒéŠã³ã€ã®äºˆå®šã‚’å…¥ã‚Œã‚ˆã†ï¼æ¥½ã—ã¿ãŒã‚ã‚‹ã‹ã‚‰ã“ãã€ä»•äº‹ã‚‚é ‘å¼µã‚Œã‚‹ã‚¿ã‚¤ãƒ—ã§ã™ğŸŒ´",
                "ğŸ“£ã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€‘\nä¸€äººã§æŠ±ãˆè¾¼ã¾ãšã€å‘¨ã‚Šã‚’é ¼ã£ã¦ï¼ã‚ãªãŸã®å¼±ã¿ã¯ã€èª°ã‹ã®å¼·ã¿ã§ã‚«ãƒãƒ¼ã§ãã¾ã™ğŸ¤",
                "ğŸªœã€ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã€‘\nã„ããªã‚Šå¤§ããªç›®æ¨™ã‚’ç«‹ã¦ãšã€å°ã•ãªã€Œã§ããŸï¼ã€ã‚’ç©ã¿é‡ã­ã¦ã€‚æ°—ã¥ã‘ã°é ãã¾ã§è¡Œã‘ã¦ã„ã‚‹ã¯ãšğŸš¶"
            ],
            closing: [
                "ğŸ’Œã€æœ€å¾Œã«â€¦ã€‘\nã‚ãªãŸã¯ã€Œå®‰å®šã€ã¨ã€Œå®Ÿè¡Œã€ã‚’å…¼ã­å‚™ãˆãŸç´ æ™´ã‚‰ã—ã„æ‰èƒ½ã®æŒã¡ä¸»ã€‚è‡ªä¿¡ã‚’æŒã£ã¦é€²ã‚“ã§ãã ã•ã„ã­ï¼ğŸ‘",
                "ğŸŒˆã€æœ€å¾Œã«â€¦ã€‘\nã©ã‚“ãªç’°å¢ƒã§ã‚‚èŠ±ã‚’å’²ã‹ã›ã‚‰ã‚Œã‚‹äººã§ã™ã€‚å¤‰åŒ–ã‚’æã‚Œãšã€æ–°ã—ã„æ³¢ã«ä¹—ã£ã¡ã‚ƒã„ã¾ã—ã‚‡ã†ï¼ğŸ„",
                "ğŸ¢ã€æœ€å¾Œã«â€¦ã€‘\nã€Œç¶™ç¶šã¯åŠ›ãªã‚Šã€ã‚’åœ°ã§è¡Œãã‚¿ã‚¤ãƒ—ã€‚ã‚ãªãŸã®ãƒšãƒ¼ã‚¹ã§æ­©ã¿ç¶šã‘ã‚Œã°ã€å¿…ãšã‚´ãƒ¼ãƒ«ã«è¾¿ã‚Šç€ã‘ã¾ã™ğŸ",
                "ğŸ¹ã€æœ€å¾Œã«â€¦ã€‘\nå¼·ã•ã¨å„ªã—ã•ã®ãƒãƒ©ãƒ³ã‚¹ãŒé­…åŠ›çš„ã€‚ãã®èª¿å’Œã‚’å¤§åˆ‡ã«ã€ã‚ãªãŸã‚‰ã—ã„ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ã‚’å¥ã§ã¦ãã ã•ã„ğŸ¶",
                "ğŸ¦…ã€æœ€å¾Œã«â€¦ã€‘\nãã®é«˜ã„è¦–åº§ã‚’å¿˜ã‚Œãªã„ã§ã€‚ç›®ã®å‰ã®ã“ã¨ã ã‘ã§ãªãã€æœªæ¥ã‚’è¦‹æ®ãˆã¦ç¾½ã°ãŸã„ã¦ï¼ğŸ•Šï¸",
                "ğŸ—ºï¸ã€æœ€å¾Œã«â€¦ã€‘\näººç”Ÿã¨ã„ã†å†’é™ºã¯ã¾ã å§‹ã¾ã£ãŸã°ã‹ã‚Šã€‚æŒã¡å‰ã®æˆ¦ç•¥çœ¼ã§ã€æœ€é«˜ã®åœ°å›³ã‚’æã„ã¦ã„ãã¾ã—ã‚‡ã†ï¼ğŸ§­"
            ]
        };

        /********************
         * Base64url + pack/unpack (6 chars)
         ********************/
        // Polyfills / graceful fallbacks for older environments
        if (!String.prototype.replaceAll) {
            String.prototype.replaceAll = function (search, replace) {
                return this.split(search).join(replace);
            };
        }

        const B64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
        // const B64I = Object.fromEntries([...B64URL].map((c, i) => [c, i]));
        const B64I = {};
        for (let i = 0; i < B64URL.length; i++) {
            B64I[B64URL[i]] = i;
        }

        // 35bit mask
        const TOTAL_BITS = 35;
        // OBF_MASK split into high (3 bits) and low (32 bits)
        // 0x12ab34cd5 -> hi: 0x1, lo: 0x2ab34cd5
        const OBF_HI = 0x1;
        const OBF_LO = 0x2ab34cd5;

        function packToCode(fields) {
            let currentVal = 0;
            let multiplier = 1;

            for (const f of fields) {
                const val = f.value;
                const max = Math.pow(2, f.bits);
                // Ensure value is within bounds
                const v = val % max;
                currentVal += v * multiplier;
                multiplier *= max;
            }

            // Obfuscate (XOR)
            // Split into lo (32 bit) and hi (rest)
            let lo = currentVal % 4294967296; // 2^32
            let hi = Math.floor(currentVal / 4294967296);

            lo = lo ^ OBF_LO;
            hi = hi ^ OBF_HI;

            // Force unsigned 32-bit for lo before recombining
            lo = lo >>> 0;

            // Recombine? No, we need to extract 6-bit chunks for Base64
            // Total 36 bits capacity (6 chars * 6 bits = 36 bits). We have 35 bits.
            // We can construct the code directly from the XOR'd bits.

            // Reconstruct full value for slicing
            let x = hi * 4294967296 + lo;

            const len = 6;
            let out = "";
            for (let i = 0; i < len; i++) {
                const chunk = Math.floor(x / Math.pow(64, i)) % 64;
                out += B64URL[chunk];
            }
            return out;
        }

        function unpackFromCode(code, fieldsBits) {
            if (!code || code.length !== 6) throw new Error("invalid code length");

            let x = 0;
            for (let i = 0; i < code.length; i++) {
                const v = B64I[code[i]];
                if (v === undefined) throw new Error("invalid code char");
                x += v * Math.pow(64, i);
            }

            // De-obfuscate
            let lo = x % 4294967296;
            let hi = Math.floor(x / 4294967296);

            lo = lo ^ OBF_LO;
            hi = hi ^ OBF_HI;

            // Recombine to raw value
            // Note: lo is treated as signed by bitwise XOR in JS, need to ensure unsigned behavior?
            // JS bitwise XOR returns signed 32-bit.
            // lo >>> 0 forces unsigned.
            lo = lo >>> 0;

            let currentVal = hi * 4294967296 + lo;
            let raw = currentVal; // Keep standard number for seeding

            const out = [];
            for (const bits of fieldsBits) {
                const max = Math.pow(2, bits);
                const val = currentVal % max;
                out.push(Math.floor(val));
                currentVal = Math.floor(currentVal / max);
            }
            // Return raw as Number (not BigInt)
            return { values: out, raw: raw };
        }

        function randInt(n) {
            if (typeof crypto !== "undefined" && crypto.getRandomValues) {
                const buf = new Uint32Array(1);
                crypto.getRandomValues(buf);
                return buf[0] % n;
            }
            // fallback to Math.random when crypto is unavailable
            return Math.floor(Math.random() * n);
        }

        // deterministic PRNG (mulberry32)
        function mulberry32(seed) {
            let a = seed >>> 0;
            return function () {
                a |= 0;
                a = (a + 0x6D2B79F5) | 0;
                let t = Math.imul(a ^ (a >>> 15), 1 | a);
                t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        /********************
         * Build result text (9 segments)
         ********************/
        function tonePreface(toneIdx) {
            const t = TONES[toneIdx];
            return `è¨ºæ–­çµæœï¼šã‚ãªãŸã¯â€œ${t}â€ã€‚\n`;
        }

        function pick6(arr, idx) {
            return arr[idx % 6];
        }

        function buildResultFromDecoded(decoded) {
            const tone = decoded.tone;
            const strength = decoded.strength;
            const state = decoded.state;
            const relation = decoded.relation;
            const wA = decoded.wA;
            const wB = decoded.wB;

            const A = AGE16[wA];
            const B = FOOD16[wB];
            const S = STRENGTHS[strength];
            const W = STATES[state];
            const T = RELATIONS[relation];

            const lines = [];
            lines.push(tonePreface(tone) + pick6(SEG.intro, tone));
            lines.push(pick6(SEG.first, strength).replaceAll("{S}", S));
            lines.push(pick6(SEG.core, state).replaceAll("{W}", W));
            lines.push(pick6(SEG.hidden, relation).replaceAll("{T}", T));
            lines.push((SEG.fatigue[wA] || SEG.fatigue[wA % SEG.fatigue.length]).replaceAll("{A}", A));
            lines.push(pick6(SEG.relation, wB).replaceAll("{B}", B));

            // è¿½åŠ ã®ã¾ã¨ã‚ãƒ»ææ¡ˆãƒ»ç·æ‹¬ã‚’ä»˜ã‘ã¦ã€è¨ºæ–­æ–‡æ›¸ã£ã½ãä»•ä¸Šã’ã‚‹
            lines.push("");
            lines.push(pick6(SEG.phase, tone));
            lines.push(pick6(SEG.advice, strength));
            lines.push(pick6(SEG.closing, state));

            return lines.join("\n");
        }

        /********************
         * Routing + Host UI
         ********************/
        const hostView = document.getElementById("hostView");
        const playView = document.getElementById("playView");
        const routePill = document.getElementById("routePill");

        const toneEl = document.getElementById("tone");
        const strengthEl = document.getElementById("strength");
        const stateEl = document.getElementById("state");
        const relationEl = document.getElementById("relation");
        const wordAEl = document.getElementById("wordA");
        const wordBEl = document.getElementById("wordB");

        const genBtn = document.getElementById("genBtn");
        const copyBtn = document.getElementById("copyBtn");
        const goPlayBtn = document.getElementById("goPlayBtn");
        const hostLinkBtn = document.getElementById("hostLinkBtn");
        const shareOut = document.getElementById("shareOut");
        const previewOut = document.getElementById("previewOut");


        function fillSelect(select, arr) {
            select.innerHTML = "";
            arr.forEach((v, i) => {
                const opt = document.createElement("option");
                opt.value = i;
                opt.textContent = v;
                select.appendChild(opt);
            });
        }

        fillSelect(toneEl, TONES);
        fillSelect(strengthEl, STRENGTHS);
        fillSelect(stateEl, STATES);
        fillSelect(relationEl, RELATIONS);
        fillSelect(wordAEl, AGE16);
        fillSelect(wordBEl, FOOD16);

        let lastCode = "";
        let lastShareUrl = "";

        function buildPreviewDecoded() {
            const tone = Number(toneEl.value);
            const strength = Number(strengthEl.value);
            const state = Number(stateEl.value);
            const relation = Number(relationEl.value);
            const wA = Number(wordAEl.value);
            const wB = Number(wordBEl.value);

            const seed32 = ((tone & 7) << 12)
                ^ ((strength & 7) << 9)
                ^ ((state & 7) << 6)
                ^ ((relation & 7) << 3)
                ^ ((wA & 15) << 1)
                ^ (wB & 15);

            const r = mulberry32(seed32 >>> 0);
            const seg5 = [0, 0, 0, 0, 0].map(() => Math.floor(r() * 6));

            return {
                tone,
                strength,
                state,
                relation,
                wA,
                wB,
                seg5,
                raw: seed32 >>> 0
            };
        }

        function updateHostPreview() {
            if (!previewOut) return;
            try {
                const decoded = buildPreviewDecoded();
                const text = buildResultFromDecoded(decoded);
                previewOut.textContent = text;
            } catch (e) {
                previewOut.textContent = "ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ";
            }
        }

        function makeShareUrl(code) {
            // hashã®ã¿é‹ç”¨ï¼ˆã‚¯ã‚¨ãƒªã‚’ä½¿ã‚ãªã„ï¼‰
            const base = location.href.split("#")[0];
            return base + "#" + code;
        }

        async function copyText(text) {
            try {
                await navigator.clipboard.writeText(text);
                return true;
            } catch (e) {
                // fallback
                const ta = document.createElement("textarea");
                ta.value = text;
                document.body.appendChild(ta);
                ta.select();
                const ok = document.execCommand("copy");
                document.body.removeChild(ta);
                return ok;
            }
        }

        function setHostOutput(code) {
            lastCode = code;
            lastShareUrl = makeShareUrl(code);
            shareOut.textContent = lastShareUrl;
            copyBtn.disabled = false;
            goPlayBtn.disabled = false;
        }

        function generateCodeFromUI() {
            const tone = Number(toneEl.value);
            const strength = Number(strengthEl.value);
            const state = Number(stateEl.value);
            const relation = Number(relationEl.value);
            const wA = Number(wordAEl.value);
            const wB = Number(wordBEl.value);

            // ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’æ’é™¤ã—ã¦å›ºå®šå€¤ã‚’ä½¿ã†
            const s0 = 0;
            const s1 = 0;
            const s2 = 0;
            const s3 = 0;
            const s4 = 0;

            const fields = [
                { value: tone, bits: 3 },
                { value: strength, bits: 3 },
                { value: state, bits: 3 },
                { value: relation, bits: 3 },
                { value: wA, bits: 4 },
                { value: wB, bits: 4 },
                { value: s0, bits: 3 },
                { value: s1, bits: 3 },
                { value: s2, bits: 3 },
                { value: s3, bits: 3 },
                { value: s4, bits: 3 },
            ];
            return packToCode(fields);
        }

        [toneEl, strengthEl, stateEl, relationEl, wordAEl, wordBEl].forEach((el) => {
            if (!el) return;
            el.addEventListener("change", updateHostPreview);
        });

        updateHostPreview();

        // Ensure the button is enabled and log interactions for debugging
        try {
            genBtn.disabled = false;
            genBtn.style.pointerEvents = 'auto';
            genBtn.addEventListener('pointerdown', () => console.log('genBtn pointerdown'));
        } catch (e) { console.warn('genBtn debug install failed', e); }

        genBtn.addEventListener("click", () => {
            try {
                console.log('genBtn clicked');
                const code = generateCodeFromUI();
                setHostOutput(code);
            } catch (e) {
                console.error("GenCode Error: " + e.message);
            }
        });

        // Global pointer logging to help find blocking overlays
        document.addEventListener('pointerdown', (ev) => {
            const el = ev.target;
            console.log('pointerdown target:', el && (el.id || el.className || el.nodeName));
        }, { capture: true });

        copyBtn.addEventListener("click", async () => {
            if (!lastShareUrl) return;
            const ok = await copyText(lastShareUrl);
            copyBtn.textContent = ok ? "ã‚³ãƒ”ãƒ¼ã—ãŸ" : "ã‚³ãƒ”ãƒ¼å¤±æ•—";
            setTimeout(() => copyBtn.textContent = "URLã‚³ãƒ”ãƒ¼", 900);
        });

        goPlayBtn.addEventListener("click", () => {
            if (!lastCode) return;
            location.hash = lastCode;
        });

        if (hostLinkBtn) {
            hostLinkBtn.addEventListener("click", () => {
                location.hash = "host";
            });
        }

        // Diagnostics button (runs a quick state dump into overlay + console)
        const diagBtnHost = document.getElementById('diagBtnHost');
        if (diagBtnHost) {
            diagBtnHost.addEventListener('click', generateDiagnostics);
        }
        const reinitBtnHost = document.getElementById('reinitBtnHost');
        if (reinitBtnHost) {
            reinitBtnHost.addEventListener('click', () => {
                console.log('reinit requested');
                try { hideOverlay(); } catch (e) { }
                const h = (location.hash || '').replace('#', '').trim();
                console.log('reinit -> hash:', h);
                if (h && h.length === 6) {
                    try { showPlay(h); } catch (e) { console.error('reinit showPlay failed', e); showHost(); }
                } else {
                    showHost();
                }
            });
        }

        /********************
         * Play UI + overlay
         ********************/
        const overlay = document.getElementById("overlay");
        const ovTitle = document.getElementById("ovTitle");
        const ovText = document.getElementById("ovText");
        const ovSub = document.getElementById("ovSub");
        const revealBtn = document.getElementById("revealBtn");
        const toHostBtn = document.getElementById("toHostBtn");
        const closeBtn = document.getElementById("closeBtn");
        let revealTimer = null;

        // typewriter for modal body
        let typewriterTimer = null;
        let typewriterToken = 0;

        function cancelTypewriter() {
            typewriterToken++;
            if (typewriterTimer) {
                clearTimeout(typewriterTimer);
                typewriterTimer = null;
            }
        }

        function typewriteText(el, fullText, opts = {}) {
            const speedMs = Number.isFinite(opts.speedMs) ? opts.speedMs : 14;
            const done = typeof opts.onDone === 'function' ? opts.onDone : null;
            const token = ++typewriterToken;

            if (!el) {
                if (done) done();
                return;
            }

            // Always start fresh
            el.textContent = "";
            let i = 0;

            const step = () => {
                if (token !== typewriterToken) return; // cancelled
                if (i >= fullText.length) {
                    typewriterTimer = null;
                    if (done) done();
                    return;
                }

                // Slightly faster through newlines/spaces for readability
                const ch = fullText[i];
                el.textContent += ch;
                i++;

                const nextDelay = (ch === "\n") ? Math.max(6, speedMs * 0.6) : speedMs;
                typewriterTimer = setTimeout(step, nextDelay);
            };

            step();
        }

        function showOverlay(title, text, sub = "") {
            cancelTypewriter();
            ovTitle.textContent = title;
            ovText.textContent = text;
            ovSub.textContent = sub;
            overlay.style.display = "flex";
        }
        function hideOverlay() {
            cancelTypewriter();
            overlay.style.display = "none";
            revealBtn.style.display = "none";
            revealBtn.classList.remove('show');
            if (toHostBtn) {
                toHostBtn.style.display = "none";
                toHostBtn.classList.remove('show');
            }
            closeBtn.style.display = "none";
            if (revealTimer) {
                clearTimeout(revealTimer);
                revealTimer = null;
            }
        }

        closeBtn.addEventListener("click", hideOverlay);

        if (revealBtn) {
            revealBtn.addEventListener('click', () => {
                cancelTypewriter();
                ovTitle.textContent = 'ãƒã‚¿ãƒãƒ¬';
                ovText.textContent = 'å®Ÿã¯ã“ã®è¨ºæ–­çµæœã¯AIãŒä½œã£ãŸã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚\nã‚ãªãŸã¸ãƒªãƒ³ã‚¯ã‚’é€ã£ãŸæ–¹ãŒé¸ã‚“ã æ–‡ç« ã§ã—ãŸã€‚\nã“ã®è¨ºæ–­ã¯ã‚¸ãƒ§ãƒ¼ã‚¯ã‚¢ãƒ—ãƒªã§ã™ã€‚\n\nã‚ãªãŸãŒã‚‚ã—ä»–ã®æ–¹ã¸ä»•æ›ã‘ãŸã„ã¨æ€ã£ãŸå ´åˆã¯ã€ä¸‹è¨˜ã®ãƒ›ã‚¹ãƒˆç”»é¢ã¸ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚';
                ovSub.textContent = '';
                revealBtn.style.display = 'none';
                revealBtn.classList.remove('show');
                if (toHostBtn) {
                    toHostBtn.style.display = 'inline-flex';
                    requestAnimationFrame(() => toHostBtn.classList.add('show'));
                }
            });
        }

        if (toHostBtn) {
            toHostBtn.addEventListener('click', () => {
                hideOverlay();
                showHost();
            });
        }

        /********************
         * DOM Mini Puzzle (bookshelf)
         ********************/
        let game = null;

        function destroyGame() {
            // Clear any DOM-based game content and timers
            if (window.__bookshelf) {
                if (window.__bookshelf.timer) clearInterval(window.__bookshelf.timer);
                window.__bookshelf = null;
            }
            const gameDiv = document.getElementById("game");
            gameDiv.innerHTML = "";
        }

        function startGameWithDecoded(decoded, resultText) {
            console.log('startGameWithDecoded', decoded);
            // New DOM-based bookshelf game
            destroyGame();
            const gameDiv = document.getElementById('game');
            if (gameDiv) gameDiv.innerHTML = '<div class="game-loading">åˆæœŸåŒ–ä¸­â€¦</div>';

            let selectedBook = null;
            function updateRotateButtons() {
                const disabled = !selectedBook || selectedBook.dataset.dragging === '1';
                if (rotateRightBtn) rotateRightBtn.disabled = disabled;
            }
            function selectBook(el) {
                if (selectedBook === el) return;
                if (selectedBook) selectedBook.classList.remove('selected');
                selectedBook = el;
                if (selectedBook) selectedBook.classList.add('selected');
                updateRotateButtons();
            }
            const COLS = 17, ROWS = 15, CELL = 40; // Grid cells
            const totalBooks = 9;
            let placedCount = 0;
            let rotateRightBtn = null;

            // Build grid and initial area
            if (gameDiv) gameDiv.innerHTML = "";
            const board = document.createElement('div');
            board.className = 'bookshelf-game';
            board.innerHTML = `
                <div class="init-col" aria-label="åˆæœŸãƒœãƒƒã‚¯ã‚¹"></div>
                <div class="rotate-col" aria-label="å›è»¢">
                    <button class="secondary" id="rotateRightBtn" disabled>å›è»¢</button>
                </div>
                <div class="grid-col" aria-label="é…ç½®ã‚°ãƒªãƒƒãƒ‰">
                    <div class="grid-root"></div>
                </div>
            `;
            gameDiv.appendChild(board);

            const initCol = board.querySelector('.init-col');
            const gridRoot = board.querySelector('.grid-root');
            rotateRightBtn = board.querySelector('#rotateRightBtn');
            gridRoot.style.width = (COLS * CELL) + 'px';
            gridRoot.style.height = (ROWS * CELL) + 'px';
            gridRoot.style.position = 'relative';
            gridRoot.style.backgroundSize = CELL + 'px ' + CELL + 'px';
            gridRoot.style.backgroundColor = 'rgba(255,255,255,0.02)';
            gridRoot.style.border = '1px solid rgba(255,255,255,0.04)';
            gridRoot.style.minWidth = '300px';
            gridRoot.style.minHeight = '200px';

            // Occupancy grid (COLS x ROWS)
            const occ = Array.from({ length: ROWS }, () => Array(COLS).fill(null));

            // Book definitions (sizes in cells): three sizes for three colors => 9 books
            const sizes = [{ w: 2, h: 7 }, { w: 1, h: 4 }, { w: 1, h: 3 }];
            const colors = ['red', 'blue', 'green'];
            const books = [];

            let idCounter = 1;
            colors.forEach((col) => {
                sizes.forEach((s) => {
                    const b = {
                        id: 'book-' + (idCounter++),
                        color: col,
                        w: s.w,
                        h: s.h,
                    };
                    books.push(b);
                });
            });

            // Create book elements in init column
            books.forEach((b, idx) => {
                console.log('create book', b.id, b.w, b.h, b.color);
                const el = document.createElement('div');
                el.className = 'book ' + b.color;
                el.dataset.id = b.id;
                el.dataset.w = b.w;
                el.dataset.h = b.h;
                el.dataset.rot = '0';
                el.style.width = (b.w * CELL - 8) + 'px';
                el.style.height = (b.h * CELL - 8) + 'px';
                el.style.margin = '8px';
                el.textContent = '';
                el.tabIndex = 0;
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectBook(el);
                });
                initCol.appendChild(el);

                // store element reference
                b.el = el;

                // pointer drag
                makeDraggable(el, b);
            });

            // Placement hint element
            const hint = document.createElement('div');
            hint.className = 'placement-hint';
            hint.style.position = 'absolute';
            hint.style.pointerEvents = 'none';
            hint.style.display = 'none';
            gridRoot.appendChild(hint);

            // Rotate failure transient message
            const rotateError = document.createElement('div');
            rotateError.className = 'rotate-error';
            rotateError.style.display = 'none';
            rotateError.textContent = '';
            gridRoot.appendChild(rotateError);
            let rotateErrorTimer = null;
            function showRotateError(msg, ms = 800) {
                rotateError.textContent = msg;
                rotateError.style.display = 'block';
                requestAnimationFrame(() => rotateError.classList.add('show'));
                if (rotateErrorTimer) { clearTimeout(rotateErrorTimer); rotateErrorTimer = null; }
                rotateErrorTimer = setTimeout(() => {
                    rotateError.classList.remove('show');
                    setTimeout(() => { rotateError.style.display = 'none'; }, 220);
                }, ms);
            }

            // Helper functions
            function canPlaceAt(x, y, w, h, ignoreId = null) {
                if (x < 0 || y < 0 || x + w > COLS || y + h > ROWS) return false;
                for (let ry = y; ry < y + h; ry++) for (let rx = x; rx < x + w; rx++) {
                    const cur = occ[ry][rx];
                    if (cur && cur !== ignoreId) return false;
                }
                return true;
            }

            function occupy(id, x, y, w, h) {
                for (let ry = y; ry < y + h; ry++) for (let rx = x; rx < x + w; rx++) occ[ry][rx] = id;
            }

            function vacate(id) {
                for (let ry = 0; ry < ROWS; ry++) for (let rx = 0; rx < COLS; rx++) if (occ[ry][rx] === id) occ[ry][rx] = null;
            }

            function makeDraggable(el, book) {
                el.style.position = 'relative';
                el.style.cursor = 'grab';

                    // Normalize client coordinates for Pointer/Mouse/Touch events
                    function getClientXY(e) {
                        if (!e) return { x: 0, y: 0 };
                        if (typeof e.clientX !== 'undefined' && typeof e.clientY !== 'undefined') return { x: e.clientX, y: e.clientY };
                        if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                        return { x: 0, y: 0 };
                    }
                let startX = 0, startY = 0;
                let offsetX = 0, offsetY = 0;
                let originalParent = el.parentElement;
                let placed = false;
                let placeX = -1, placeY = -1;
                let dragging = false;
                let dragStarted = false;
                const DRAG_THRESHOLD = 6;

                function startDrag(e) {
                    dragStarted = true;
                    dragging = true;
                    el.dataset.dragging = '1';
                    el.style.opacity = '0.3';
                    console.log('startDrag', book && book.id ? book.id : el.dataset.id, 'placed=', placed);

                    const startRect = el.getBoundingClientRect();
                    const p = getClientXY(e);
                    offsetX = p.x - startRect.left;
                    offsetY = p.y - startRect.top;

                    // if currently placed, free occupancy so it can move
                    if (el.dataset.placed === '1') {
                        placed = true;
                        el.dataset.placed = '0';
                        placeX = Number(el.dataset.x);
                        placeY = Number(el.dataset.y);
                        vacate(el.dataset.id);
                    } else {
                        placed = false;
                    }

                    // move to body to allow absolute positioning over everything
                    document.body.appendChild(el);
                    el.style.position = 'fixed';
                    el.style.zIndex = 9999;
                    el.style.left = startRect.left + 'px';
                    el.style.top = startRect.top + 'px';

                    // normalized coordinates
                    moveAt(p.x, p.y);
                }

                function onPointerDown(e) {
                    e.preventDefault();
                    const p = getClientXY(e);
                    console.log('onPointerDown', book && book.id ? book.id : el.dataset.id, 'type=', e.type, 'client=', Math.round(p.x), Math.round(p.y));
                    // Guard for environments where pointerId or setPointerCapture may be unavailable
                    if (typeof e.pointerId !== 'undefined' && el.setPointerCapture) {
                        try { el.setPointerCapture(e.pointerId); } catch (err) { console.warn('setPointerCapture failed', err); }
                    }
                    selectBook(el);
                    // Use normalized coords
                    startX = p.x;
                    startY = p.y;
                    dragging = false;
                    dragStarted = false;
                    el.dataset.dragging = '0';
                    updateRotateButtons();

                    window.addEventListener('pointermove', onPointerMove);
                    window.addEventListener('pointerup', onPointerUp);
                    // Fallback for older browsers or non-pointer events
                    window.addEventListener('mousemove', onPointerMove);
                    window.addEventListener('mouseup', onPointerUp);
                    window.addEventListener('touchmove', onPointerMove, { passive: false });
                    window.addEventListener('touchend', onPointerUp);
                }

                function moveAt(clientX, clientY) {
                    // show hint over grid if inside
                    const gridRect = gridRoot.getBoundingClientRect();
                    const rot = Number(el.dataset.rot) || 0;
                    const w = (rot % 2 === 0) ? Number(el.dataset.w) : Number(el.dataset.h);
                    const h = (rot % 2 === 0) ? Number(el.dataset.h) : Number(el.dataset.w);
                    const desiredLeft = clientX - offsetX;
                    const desiredTop = clientY - offsetY;
                    const gx = Math.floor((desiredLeft - gridRect.left) / CELL);
                    const gy = Math.floor((desiredTop - gridRect.top) / CELL);
                    const inside = desiredLeft >= gridRect.left
                        && desiredTop >= gridRect.top
                        && desiredLeft <= (gridRect.right - w * CELL)
                        && desiredTop <= (gridRect.bottom - h * CELL);

                    if (inside) {
                        // snap book to grid overlay while dragging
                        el.style.left = (gridRect.left + gx * CELL) + 'px';
                        el.style.top = (gridRect.top + gy * CELL) + 'px';
                        el.style.width = (w * CELL - 8) + 'px';
                        el.style.height = (h * CELL - 8) + 'px';

                        if (canPlaceAt(gx, gy, w, h, el.dataset.id)) {
                            hint.style.display = 'block';
                            hint.style.left = (gx * CELL) + 'px';
                            hint.style.top = (gy * CELL) + 'px';
                            hint.style.width = (w * CELL) + 'px';
                            hint.style.height = (h * CELL) + 'px';
                            hint.style.background = 'rgba(138, 255, 165, 0.25)';
                            hint.style.border = '2px solid rgba(34,150,90,0.9)';
                        } else {
                            hint.style.display = 'block';
                            hint.style.left = (Math.min(Math.max(0, gx), COLS - 1) * CELL) + 'px';
                            hint.style.top = (Math.min(Math.max(0, gy), ROWS - 1) * CELL) + 'px';
                            hint.style.width = (w * CELL) + 'px';
                            hint.style.height = (h * CELL) + 'px';
                            hint.style.background = 'rgba(255, 100, 100, 0.08)';
                            hint.style.border = '2px dashed rgba(200,50,50,0.9)';
                        }
                    } else {
                        el.style.left = desiredLeft + 'px';
                        el.style.top = desiredTop + 'px';
                        el.style.width = (w * CELL - 8) + 'px';
                        el.style.height = (h * CELL - 8) + 'px';
                        hint.style.display = 'none';
                    }
                }

                function onPointerMove(e) {
                    // prevent touch scrolling while dragging
                    if (e.type === 'touchmove') try { e.preventDefault(); } catch (err) { /* ignore */ }
                    const p = getClientXY(e);
                    const dx = p.x - startX;
                    const dy = p.y - startY;
                    if (!dragStarted) {
                        if (Math.hypot(dx, dy) < DRAG_THRESHOLD) return;
                        console.log('drag threshold exceeded, starting drag', book && book.id ? book.id : el.dataset.id, 'dx=', Math.round(dx), 'dy=', Math.round(dy));
                        startDrag(e);
                    }
                    if (!dragging) return;
                    moveAt(p.x, p.y);
                }

                function onPointerUp(e) {
                    dragging = false;
                    el.dataset.dragging = '0';
                    el.style.opacity = '';
                    if (typeof e.pointerId !== 'undefined' && el.releasePointerCapture) {
                        try { el.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                    }
                    window.removeEventListener('pointermove', onPointerMove);
                    window.removeEventListener('pointerup', onPointerUp);
                    window.removeEventListener('mousemove', onPointerMove);
                    window.removeEventListener('mouseup', onPointerUp);
                    window.removeEventListener('touchmove', onPointerMove);
                    window.removeEventListener('touchend', onPointerUp);

                    updateRotateButtons();

                    if (!dragStarted) {
                        return;
                    }

                    const gridRect = gridRoot.getBoundingClientRect();
                    const p = getClientXY(e);
                    console.log('onPointerUp', book && book.id ? book.id : el.dataset.id, 'client=', Math.round(p.x), Math.round(p.y));
                    const rot = Number(el.dataset.rot) || 0;
                    const w = (rot % 2 === 0) ? Number(el.dataset.w) : Number(el.dataset.h);
                    const h = (rot % 2 === 0) ? Number(el.dataset.h) : Number(el.dataset.w);
                    const desiredLeft = p.x - offsetX;
                    const desiredTop = p.y - offsetY;
                    const gx = Math.floor((desiredLeft - gridRect.left) / CELL);
                    const gy = Math.floor((desiredTop - gridRect.top) / CELL);
                    const inside = desiredLeft >= gridRect.left
                        && desiredTop >= gridRect.top
                        && desiredLeft <= (gridRect.right - w * CELL)
                        && desiredTop <= (gridRect.bottom - h * CELL);

                    if (inside && canPlaceAt(gx, gy, w, h, el.dataset.id)) {
                        // place into grid (use grid-local coords)
                        el.style.left = (gx * CELL) + 'px';
                        el.style.top = (gy * CELL) + 'px';
                        el.style.width = (w * CELL - 8) + 'px';
                        el.style.height = (h * CELL - 8) + 'px';
                        gridRoot.appendChild(el);
                        el.style.position = 'absolute';
                        el.dataset.placed = '1';
                        el.dataset.x = gx;
                        el.dataset.y = gy;
                        occupy(el.dataset.id, gx, gy, w, h);
                        hint.style.display = 'none';
                        placedCount++;
                    } else {
                        // return to init column
                        initCol.appendChild(el);
                        el.style.position = 'relative';
                        el.style.left = '';
                        el.style.top = '';
                        el.style.zIndex = '';
                        const rot = Number(el.dataset.rot) || 0;
                        const w = (rot % 2 === 0) ? Number(el.dataset.w) : Number(el.dataset.h);
                        const h = (rot % 2 === 0) ? Number(el.dataset.h) : Number(el.dataset.w);
                        el.style.width = (w * CELL - 8) + 'px';
                        el.style.height = (h * CELL - 8) + 'px';
                        if (placed) {
                            // it was moved out, so update counters
                            placedCount = Math.max(0, placedCount - 1);
                        }
                        hint.style.display = 'none';
                    }
                }

                // Prevent native HTML5 dragstart which can interfere on some browsers (notably Chrome on macOS)
                el.addEventListener('dragstart', (ev) => { ev.preventDefault(); });
                el.addEventListener('pointerdown', onPointerDown);
                // Fallbacks for environments where pointer events aren't emitted for down
                el.addEventListener('mousedown', onPointerDown);
                el.addEventListener('touchstart', onPointerDown, { passive: false });
            }

            function rotateSelected(direction) {
                if (!selectedBook || selectedBook.dataset.dragging === '1') return;
                const el = selectedBook;
                const curRot = Number(el.dataset.rot) || 0;
                const rot = (curRot + (direction === 'left' ? 3 : 1)) % 4;
                const curX = el.dataset.placed === '1' ? Number(el.dataset.x) : null;
                const curY = el.dataset.placed === '1' ? Number(el.dataset.y) : null;
                const w = (rot % 2 === 0) ? Number(el.dataset.w) : Number(el.dataset.h);
                const h = (rot % 2 === 0) ? Number(el.dataset.h) : Number(el.dataset.w);
                if (el.dataset.placed === '1') {
                    const oldW = (curRot % 2 === 0) ? Number(el.dataset.w) : Number(el.dataset.h);
                    const oldH = (curRot % 2 === 0) ? Number(el.dataset.h) : Number(el.dataset.w);
                    const centerX = curX + oldW / 2;
                    const centerY = curY + oldH / 2;
                    const newX = Math.round(centerX - w / 2);
                    const newY = Math.round(centerY - h / 2);
                    vacate(el.dataset.id);
                    if (canPlaceAt(newX, newY, w, h, el.dataset.id)) {
                        el.dataset.rot = String(rot);
                        el.setAttribute('data-rot', String(rot));
                        el.style.width = (w * CELL - 8) + 'px';
                        el.style.height = (h * CELL - 8) + 'px';
                        el.style.left = (newX * CELL) + 'px';
                        el.style.top = (newY * CELL) + 'px';
                        el.dataset.x = newX;
                        el.dataset.y = newY;
                        occupy(el.dataset.id, newX, newY, w, h);
                    } else {
                        occupy(el.dataset.id, curX, curY, oldW, oldH);
                        el.animate([{ transform: 'translateX(-4px)' }, { transform: 'translateX(4px)' }, { transform: 'translateX(0)' }], { duration: 180 });
                        try { showRotateError('å›è»¢ã§ãã‚‹ã‚¹ãƒšãƒ¼ã‚¹ãŒãªã„ï¼'); } catch (e) { /* ignore */ }
                    }
                } else {
                    el.dataset.rot = String(rot);
                    el.setAttribute('data-rot', String(rot));
                    const w2 = (rot % 2 === 0) ? Number(el.dataset.w) : Number(el.dataset.h);
                    const h2 = (rot % 2 === 0) ? Number(el.dataset.h) : Number(el.dataset.w);
                    el.style.width = (w2 * CELL - 8) + 'px';
                    el.style.height = (h2 * CELL - 8) + 'px';
                }
            }

            if (rotateRightBtn && !rotateRightBtn.dataset.bound) {
                rotateRightBtn.dataset.bound = '1';
                rotateRightBtn.addEventListener('click', () => rotateSelected('right'));
            }
            updateRotateButtons();

            function makeDoubleClickRotate(el, book) {
                let last = 0;
                function tryRotate() {
                    if (el.dataset.dragging === '1') return;
                    const rot = Number(el.dataset.rot) ^ 1;
                    const curX = el.dataset.placed === '1' ? Number(el.dataset.x) : null;
                    const curY = el.dataset.placed === '1' ? Number(el.dataset.y) : null;
                    const w = rot === 0 ? Number(el.dataset.w) : Number(el.dataset.h);
                    const h = rot === 0 ? Number(el.dataset.h) : Number(el.dataset.w);
                    if (el.dataset.placed === '1') {
                        // check if rotation fits
                        const oldW = Number(el.dataset.rot) === 0 ? Number(el.dataset.w) : Number(el.dataset.h);
                        const oldH = Number(el.dataset.rot) === 0 ? Number(el.dataset.h) : Number(el.dataset.w);
                        vacate(el.dataset.id);
                        if (canPlaceAt(curX, curY, w, h, el.dataset.id)) {
                            el.dataset.rot = String(rot);
                            el.style.width = (w * CELL - 8) + 'px';
                            el.style.height = (h * CELL - 8) + 'px';
                            occupy(el.dataset.id, curX, curY, w, h);
                        } else {
                            // revert occupy with old size
                            occupy(el.dataset.id, curX, curY, oldW, oldH);
                            // show a small shake
                            el.animate([{ transform: 'translateX(-4px)' }, { transform: 'translateX(4px)' }, { transform: 'translateX(0)' }], { duration: 180 });
                            try { showRotateError('å›è»¢ã§ãã‚‹ã‚¹ãƒšãƒ¼ã‚¹ãŒãªã„ï¼'); } catch (e) { /* ignore */ }
                        }
                    } else {
                        // when not placed, just toggle size
                        el.dataset.rot = String(rot);
                        const w2 = rot === 0 ? Number(el.dataset.w) : Number(el.dataset.h);
                        const h2 = rot === 0 ? Number(el.dataset.h) : Number(el.dataset.w);
                        el.style.width = (w2 * CELL - 8) + 'px';
                        el.style.height = (h2 * CELL - 8) + 'px';
                    }
                }

                el.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    tryRotate();
                });

                el.addEventListener('pointerup', (e) => {
                    const now = Date.now();
                    if (now - last < 350) {
                        // double tap
                        last = 0;
                        tryRotate();
                    } else {
                        last = now;
                    }
                });
            }

            // Diagnosis button (use existing overlay)
            function runAnalysisSequence(onDone) {
                const steps = [
                    { t: 0, msg: 'ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­â€¦' },
                    { t: 25, msg: 'é…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è§£æä¸­â€¦' },
                    { t: 50, msg: 'å‚¾å‘ã‚’æŠ½å‡ºä¸­â€¦' },
                    { t: 75, msg: 'çµæœã‚’ç”Ÿæˆä¸­â€¦' },
                    { t: 100, msg: 'è§£æå®Œäº†' }
                ];

                showOverlay('è§£æä¸­â€¦', 'ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚', '');
                let idx = 0;
                let pct = 0;
                const tick = () => {
                    if (idx < steps.length && pct >= steps[idx].t) {
                        ovText.textContent = steps[idx].msg;
                        idx++;
                    }
                    ovSub.textContent = `é€²æ—: ${pct}%`;
                    if (pct >= 100) {
                        clearInterval(timer);
                        setTimeout(() => onDone && onDone(), 400);
                        return;
                    }
                    pct += 2.5;
                };
                const timer = setInterval(tick, 80);
                tick();
            }

            const diagBtn = document.createElement('button');
            diagBtn.className = 'secondary diag-btn';
            diagBtn.textContent = 'æ•´ç†å®Œäº†ï¼ è¨ºæ–­çµæœã‚’è¦‹ã‚‹';
            diagBtn.onclick = () => {
                // show result reconstructed from host parameters
                const title = 'è¨ºæ–­çµæœ';
                const text = resultText;
                runAnalysisSequence(() => {
                    // Show overlay first, then type out body gradually
                    showOverlay(title, '', '');
                    closeBtn.style.display = 'inline-flex';
                    revealBtn.style.display = 'inline-flex';
                    revealBtn.classList.remove('show');
                    if (revealTimer) {
                        clearTimeout(revealTimer);
                        revealTimer = null;
                    }

                    // Typewriter effect: start reveal timer after the text is fully printed
                    typewriteText(ovText, text, {
                        speedMs: 12,
                        onDone: () => {
                            revealTimer = setTimeout(() => {
                                revealBtn.classList.add('show');
                            }, 7000);
                        }
                    });
                });
            };

            // place diag button after grid
            const gridCol = board.querySelector('.grid-col');
            gridCol.appendChild(diagBtn);

            // store reference for cleanup
            window.__bookshelf = { occ, books, board };

            // End of startGameWithDecoded
        }

        function typewriter(text, el, speedMs, onDone) {
            el.textContent = "";
            let i = 0;
            const t = setInterval(() => {
                el.textContent += text[i] || "";
                i++;
                if (i >= text.length) {
                    clearInterval(t);
                    onDone && onDone();
                }
            }, speedMs);
        }

        // Diagnostic helper
        function generateDiagnostics() {
            try {
                const gameEl = document.querySelector('#game');
                const bookshelf = !!document.querySelector('.bookshelf-game');
                const loading = !!document.querySelector('.game-loading');
                const bookCount = document.querySelectorAll('.book').length;
                const occInfo = (window.__bookshelf && window.__bookshelf.occ) ? 'initialized' : 'not initialized';
                const firstBookInfo = (function () { const b = document.querySelector('.book'); if (!b) return 'no book'; const r = b.getBoundingClientRect(); return `w:${Math.round(r.width)} h:${Math.round(r.height)} left:${Math.round(r.left)} top:${Math.round(r.top)}` })();
                const overlayVisible = (overlay && overlay.style && overlay.style.display && overlay.style.display !== 'none') ? 'visible' : 'hidden';
                const ovTextVal = ovText ? ovText.textContent : '';

                const report = [`bookshelf:${bookshelf}`, `loading:${loading}`, `bookCount:${bookCount}`, `occ:${occInfo}`, `overlay:${overlayVisible}`, `ovText:${ovTextVal}`, `firstBook:${firstBookInfo}`].join('\n');
                document.querySelectorAll('.book').forEach((b, i) => { b.style.outline = '2px solid rgba(255,255,255,0.6)'; b.style.zIndex = 9999; });
            } catch (e) {
                console.error('generateDiagnostics failed', e);
                showOverlay('è¨ºæ–­ã‚¨ãƒ©ãƒ¼', String(e));
            }
        }
        function showHost() {
            try { destroyGame(); } catch (e) { /* ignore */ }
            hostView.style.display = "block";
            playView.style.display = "none";
            routePill.textContent = "#host";
            hideOverlay();
        }
        function showPlay(code) {
            console.log('showPlay called with', code);
            hostView.style.display = "none";
            playView.style.display = "block";
            routePill.textContent = "#" + code;
            // show a visible loading placeholder while initializing
            const gameDiv = document.getElementById('game');
            if (gameDiv) {
                gameDiv.innerHTML = '<div class="game-loading">ãƒ­ãƒ¼ãƒ‰ä¸­â€¦</div>';
            }
            // decode
            const bits = [3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3];
            let decoded;
            try {
                const { values, raw } = unpackFromCode(code, bits);
                decoded = {
                    tone: values[0],
                    strength: values[1],
                    state: values[2],
                    relation: values[3],
                    wA: values[4],
                    wB: values[5],
                    seg5: values.slice(6, 11),
                    raw
                };
            } catch (e) {
                showOverlay("ã‚¨ãƒ©ãƒ¼", "ã“ã®URLã®ã‚³ãƒ¼ãƒ‰ãŒä¸æ­£ã¿ãŸã„ã€‚\nãƒ›ã‚¹ãƒˆã«ä½œã‚Šç›´ã—ã¦ã‚‚ã‚‰ã£ã¦ã­ã€‚");
                revealBtn.style.display = "none";
                closeBtn.style.display = "inline-block";
                hostView.style.display = "";
                playView.style.display = "none";
                return;
            }

            let resultText;
            try {
                resultText = buildResultFromDecoded(decoded);
            } catch (e) {
                console.error(e);
                showOverlay("ã‚¨ãƒ©ãƒ¼", "è¨ºæ–­æ–‡ã®ç”Ÿæˆã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
                revealBtn.style.display = "none";
                closeBtn.style.display = "inline-block";
                hostView.style.display = "";
                playView.style.display = "none";
                return;
            }

            try {
                startGameWithDecoded(decoded, resultText);
            } catch (e) {
                console.error(e);
                showOverlay("ã‚¨ãƒ©ãƒ¼", "ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
                revealBtn.style.display = "none";
                closeBtn.style.display = "inline-block";
                hostView.style.display = "";
                playView.style.display = "none";
                return;
            }
        }

        function route() {
            try {
                // Try hash first, then query params 'code' or 'c' as fallback
                const rawHash = (location.hash || "").replace("#", "").trim();
                const params = new URLSearchParams(location.search || "");
                const paramCode = params.get('code') || params.get('c') || null;
                console.log('route: href=', location.href, 'hash=', rawHash, 'search=', location.search, 'paramCode=', paramCode);

                let h = rawHash;
                if (!h && paramCode) h = String(paramCode).trim();

                if (!h || h === "host") {
                    showHost();
                } else if (h.length === 6) {
                    showPlay(h);
                } else {
                    // unknown hash/param -> host
                    console.warn('route: unknown code, falling back to host. code=', h);
                    showHost();
                }
            } catch (e) {
                console.error(e);
                showOverlay("ã‚¨ãƒ©ãƒ¼", "ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
                showHost();
            }
        }

        window.addEventListener("error", (ev) => {
            console.error("Global error:", ev.error || ev.message);
            try { showOverlay("ã‚¨ãƒ©ãƒ¼", "äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚è©³ã—ãã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"); } catch (e) { /* ignore */ }
            try { showHost(); } catch (e) { /* ignore */ }
        });

        window.addEventListener("hashchange", route);
        route();
    </script>
</body>

</html>